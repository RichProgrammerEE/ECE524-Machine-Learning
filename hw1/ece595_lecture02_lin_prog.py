# -*- coding: utf-8 -*-
"""ECE595_lecture02_lin_prog.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1h_1oTz-Qocd-09KKTmbBw4E5mSa6UaCq

**Legendre Polynomial vs Ordinary Polynomial**
"""

# Least Squares with Clean Data
import numpy as np
import matplotlib.pyplot as plt
from scipy.special import eval_legendre # Legendre polynomial

N = 50
x = np.linspace(-1,1,N)
a = np.array([-0.001, 0.01, 0.55, 1.5, 1.2])
sigma = 0.2 # standard deviation of the noise
y = a[0] * eval_legendre(0,x) + a[1] * eval_legendre(1,x) + \
  a[2] * eval_legendre(2,x) + a[3] * eval_legendre(3,x) + \
  a[4] * eval_legendre(4,x) + 0.2 * np.random.randn(N)

# legendre polynomial
A_leg = np.column_stack((eval_legendre(0,x), eval_legendre(1,x), \
                     eval_legendre(2,x), eval_legendre(3,x), \
                     eval_legendre(4,x)))

# ordinary polynomial
A_ord = np.column_stack((x**0, x**1, x**2, x**3, x**4))

# legendre polynomial
theta = np.linalg.lstsq(A_leg, y, rcond=None)[0] # do not compute (A^TA)^-1 Yourself!
t = np.linspace(-1,1,200)
yhat = theta[0] * eval_legendre(0,t) + theta[1] * eval_legendre(1,t) + \
        theta[2] * eval_legendre(2,t) + theta[3] * eval_legendre(3,t) + \
        theta[4] * eval_legendre(4,t)

print(theta)

plt.plot(x,y, 'o', markersize=12)
plt.plot(t, yhat, linewidth=8)
plt.title('Legendre Polynomial')
plt.xlabel('t')
plt.ylabel('y')
plt.show()

# ordinary polynomial
theta = np.linalg.lstsq(A_ord, y, rcond=None)[0] # do not compute (X^TX)^-1 Yourself!
yhat = theta[0] * t**0 + theta[1] * t**1 + \
        theta[2] * t**2 + theta[3] * t**3 + \
        theta[4] * t**4

print(theta)

plt.plot(x,y, 'o', markersize=12)
plt.plot(t, yhat, linewidth=8)
plt.title('Ordinary Polynomial')
plt.xlabel('t')
plt.ylabel('y')
plt.show()

"""# **Ill-condition of ordinary polynomial**"""

import numpy as np
import matplotlib.pyplot as plt
from scipy.special import eval_legendre # Legendre polynomial

N = 1000
x = np.linspace(-1,1,N)
d = 10

# legendre polynomial
A_leg = np.column_stack([eval_legendre(i,x) for i in range(d)]) # (N,d)

# ordinary polynomial
A_ord = np.column_stack([x**i for i in range(d)]) # (N,d)

# SVD to look at eigenvalues
_,s_leg,_ = np.linalg.svd(A_leg)
_,s_ord,_ = np.linalg.svd(A_ord)

print(f'Legendre Polynomial Basis Singular values: {s_leg}')
print(f'Ordinary Polynomial Basis Singular values: {s_ord}')

"""**Auto-Regressive Model**"""

import numpy as np
import matplotlib.pyplot as plt
from scipy.linalg import toeplitz

N     = 500
y     = np.cumsum(0.2*np.random.randn(N)) + 0.05*np.random.randn(N)

L     = 100 # y_n = y_n-1 + y_n-2 + ... + y_n-100
c     = np.hstack((0, y[0:400-1])) # y[0:400]
r     = np.zeros(L) # [0,0,...,0]
A     = toeplitz(c,r) # [399,100]
# [y_0, 0, 0, 0, ..., 0]
# [y_1, y_0, 0, ..., 0]
# ...
# [y_N-1, y_N-2, ...., y_N-100]
theta = np.linalg.lstsq(A, y[0:400], rcond=None)[0]

yhat        = np.zeros(N)
yhat[0:400] = np.dot(A, theta)

plt.plot(y, 'o')
plt.plot(yhat,linewidth=4)

for i in range(400,500):
  yhat[i] = np.dot(yhat[i-L:i], theta)

plt.plot(y, 'o')
plt.plot(yhat,linewidth=4)

"""**Outliers**"""

# Least Squares with clean data
import numpy as np
import matplotlib.pyplot as plt
from scipy.special import eval_legendre

N = 50
x = np.linspace(-1,1,N)
a = np.array([-0.001, 0.01, 0.55, 1.5, 1.2])
y = a[0]*eval_legendre(0,x) + a[1]*eval_legendre(1,x) + \
  a[2]*eval_legendre(2,x) + a[3]*eval_legendre(3,x) + \
  a[4]*eval_legendre(4,x) + 0.2*np.random.randn(N)

X = np.column_stack((eval_legendre(0,x), eval_legendre(1,x), \
                     eval_legendre(2,x), eval_legendre(3,x), \
                     eval_legendre(4,x)))
theta = np.linalg.lstsq(X, y, rcond=None)[0]
t     = np.linspace(-1, 1, 200);
yhat  = theta[0]*eval_legendre(0,t) + theta[1]*eval_legendre(1,t) + \
        theta[2]*eval_legendre(2,t) + theta[3]*eval_legendre(3,t) + \
        theta[4]*eval_legendre(4,t)
plt.plot(x,y,'o',markersize=12)
plt.plot(t,yhat, linewidth=8)
plt.show()

# Least squares with outliers
import numpy as np
import matplotlib.pyplot as plt
from scipy.special import eval_legendre

N = 50
x = np.linspace(-1,1,N)
a = np.array([-0.001, 0.01, 0.55, 1.5, 1.2])
y = a[0]*eval_legendre(0,x) + a[1]*eval_legendre(1,x) + \
    a[2]*eval_legendre(2,x) + a[3]*eval_legendre(3,x) + \
    a[4]*eval_legendre(4,x) + 0.2*np.random.randn(N)
idx = [10,16,23,37,45]    # Outlier locations
y[idx] = 5                # Outlier values

X = np.column_stack((np.ones(N), x, x**2, x**3, x**4))
beta = np.linalg.lstsq(X, y, rcond=None)[0]
t    = np.linspace(-1, 1, 200);
yhat = beta[0]*np.ones(200) + beta[1]*t + beta[2]*t**2 + beta[3]*t**3 + beta[4]*t**4
plt.plot(x,y,'o',markersize=12)
plt.plot(t,yhat, linewidth=8)
plt.show()

# Linear Programming
import numpy as np
import matplotlib.pyplot as plt
from scipy.special import eval_legendre
from scipy.optimize import linprog

N = 50
x = np.linspace(-1,1,N)
a = np.array([-0.001, 0.01, 0.55, 1.5, 1.2])
y = a[0]*eval_legendre(0,x) + a[1]*eval_legendre(1,x) + \
    a[2]*eval_legendre(2,x) + a[3]*eval_legendre(3,x) + \
    a[4]*eval_legendre(4,x) + 0.2*np.random.randn(N)
idx = [10,16,23,37,45]    # Outlier locations
y[idx] = 5                # Outlier values

## For homework 1, Problem 3